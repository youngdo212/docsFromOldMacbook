**오늘 한 일:**

* 알고리즘: 프로그래머스(레벨2 124나라)
* 웹자판기 PR



**내일 할 일:**

* 실행 컨텍스트 공부
* 알고리즘: 프로그래머스(레벨2 땅따먹기)



## 회고

알고리즘에 시간을 너무 많이 소비했다(4시간). 결국 나열하면 쉽게 풀리는 문제였다. 알고리즘 답을 찾기 어려울 경우 일단 나열해보자.



# 웹자판기 기능추가 및 리팩토링

#### 잔돈 반환 기능 구현

* `Action`을 통해 자판기에서 지갑으로 잔돈을 넘겨주기로 함

  * 잔돈은 어떤 형태여야 할까?
    * 처음에는 단순히 문자열 데이터를 넘겨줌.`"450"`
    * 근데 현실에서는 자판기가 잔돈을 화폐단위로(100원별로, 500원 별로) 변환시켜 사용자에게 전달해줌
    * 게다가 지갑에서 돈의 단위별로 쪼개서 넣어짐
    * 그렇다면 key-value형태의 객체가 좋다고 생각.`{50:1, 100:4}`
    * 잔돈객체는 현실의 경우에 따라 자판기에서 생성되도록 함
  * 잔돈 생성 규칙
    * 가장 큰 화폐 단위부터 잔돈을 나누기로 함
  * 문제점
    * 돈 데이터 형태가 지갑 > 자판기 이동할때`문자열`와 자판기 > 지갑 이동할 때`객체`가 다르다는 문제
    * 통일성이냐 효율성이냐: 지금은 효율성을 택했지만 왠지 통일성을 택하는 순간이 올 것 같다(모듈단위로 리팩토링한다고 가정하면 통일된 자료구조 형태가 더 좋을 것 같다)
* 지연 처리 기능

  * timeoutID와 clearTimeout을 이용해 비동기 동작 다룸

#### wallet 클래스 리팩토링

##### 1) 생성자의 인자로 각 돈 데이터를 받도록 변경

- render함수 필요

##### 2) Wallet클래스에서 이루어지는 작업은

1. price에 매칭되는 카운트 조작
2. totalMoney 조작

뿐이다. 현재 1번작업을 수행할 경우 매번 querySelector로 해당되는 엘리먼트를 찾고 있다. 효율성을 늘리기 위해서 미리 wallet클래스 프로퍼티로 `{price: countElem}`형태의 자료(moneyCountElemDict)가 있으면 좋겠다는 생각이 들었다.

##### 3) 새로운 생성자 규칙

wallet클래스 생성자에서는 객체의 속성만 초기화 시키기로 함

render및 이벤트 등록은 `init()`을 통해 외부에서 초기화 하도록 설정

##### 4) 지갑 전체금액을 계산하는 메소드 추가: calcTotalMoney()

increase와 decrease에서 전체 금액을 계산하는 로직이 중복되서 생성

##### 5) moneyCount를 조작하는 메소드 추가: manipulateMoneyCount(Elem, count)

count를 통해 음수와 양수값 모두 받도록 함. increase decrease에서 발생하는 중복을 제거하고, 범용성 있는 메소드를 만들기 위해 구현

#### 고민

Q. 데이터의 형태를 변수에 명시해 주는게 좋을까?

ex) 리스트 형태의 item : itemList

딕셔너리 형태의 item : itemDict